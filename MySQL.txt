索引
1. 索引分类
	按照存储分：聚集性索引和非聚集性索引
		聚集性索引：索引中键的顺序和物理存放地址顺序一致，一般主键为聚集性索引，没有主键则是表的第一个唯一非空索引做聚集索引，如果都没有innodb会生成隐式的聚集索引。
		非聚集性索引：索引中键的顺序和物理存放地址顺序不一致
		二者差别，聚集性索引，索引结构的叶子节点存有行数据，非聚集性索引的叶子节点存储的是聚集性索引主键，这样在查询非聚集性索引时，先找到主键，再用主键去聚集性索引找数据。
	注意：对聚集性索引排序可能会对磁盘IO产生较大压力
	
	按照类型分：普通索引，唯一索引， 组合索引
	
	普通索引：
		创建： CREATE INDEX 索引名 ON 表名(字段名(索引字段长度,可不写))
		删除： DROP INDEX 索引名
		查看索引：show INDEX from 表名
		
	唯一索引：索引列的值必须唯一可以允许有空值
		创建： CREATE UNIQUE INDEX 索引名 ON 表名(字段名(索引字段长度))
		
	组合索引：有“最左前缀”原则，即是从最左边开始组合，要有最左边的字段，否则查询不走该索引
        创建：CREATE INDEX 索引名 ON 表名(字段名(索引字段长度),字段名(索引字段长度))
		
2.高级语法

	使用查询语句创建表
	CREATE TABLE staff_temp AS SELECT * FROM staff LIMIT 10;
	从一个表中复制数据插入指定表
	INSERT INTO staff_temp SELECT * FROM staff;
	
	子查询：
		where处子查询
		SELECT * FROM 表名 WHERE 字段 操作符 (SELECT 字段 FROM 表名)
		注意：子查询必须是对一个字段进行查询
		
		from处子查询
		SELECT * FROM (SELECT * FROM 表名) AS 别名
		注意：子查询必须有别名
		
		select处子查询
		SELECT 字段1, (SELECT 字段2 FROM 表名) FROM 表名
		注意：子查询只能查一个字段，且只能返回一行数据
		
	合并：
	   UNION
	   SELECT * FROM 表名 UNION SELECT * FROM 表名
	   注意：
	   UNION 会去重
	   UNION ALL 不会去重
	   两个查询必须字段相同，或者列数相同，不可以直接加排序，可以作为子查询再排序
	   
3. SQL优化
		
		建立适当的索引(索引结构和原理)
		明确字段，少用SELECT *
		尽量避免 IN 和 NOT IN, 如果是连续值用BETWEEN 2 AND 3代替，不连续的使用子查询EXISTS代替，SELECT * FROM T1 WHERE EXISTS (SELECT * FROM T2)
		如果两个不同字段查询条件可以用UNION替代
		LIKE 模糊搜索 'abc%' 开始如果模糊匹配会导致全表扫描
		避免null值作为where条件，设计时可以加上默认值
	    不要在where左侧进行函数或者表达式运算，如 where score/10 = 9,改为右侧计算
		
4. MySQL索引原理

        平衡二叉树(AVL Tree)：在二叉树的基础上，任何节点的两个子树的高度差<=1。
		平衡二叉树在增加或减少节点后，会不平衡，通过旋转后恢复平衡。
		平衡多路查找树(B-Tree), 所有子节点都在同一层，关键字升序排列，一个节点有多个(超过2个)子节点，每一个节点也会存储数据。
		B+Tree，因为每个节点的大小有限，如果非叶子节点也存储数据，这样非叶子节点存储的Key就会变少，同样的数据量，树的深度就越高。
		B+Tree非叶子节点(innoDB,每个节点叫页，默认16K)不再存储数据，只存储key，这样存储的key值数量大大增加，树的深度降低了，减少了访问磁盘的次数，
		B+Tree叶子节点存储key和行数据，并且所有叶子节点也是链式环结构，是有序的，这就是聚集性索引。
